<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RAPID EDGE OMEGA</title>
    <style>
        /* お正月＆ハッカー仕様 */
        body {
            background-color: #050505;
            color: #00FF00;
            font-family: 'Courier New', monospace;
            text-align: center;
            overflow: hidden;
            touch-action: manipulation;
            margin: 0; padding: 0;
        }
        h1 { font-size: 20px; text-shadow: 0 0 10px #00FF00; margin-top: 10px; }
        
        .screen { display: none; height: 100vh; width: 100%; flex-direction: column; align-items: center; justify-content: center; }
        .active { display: flex; }

        .menu-btn {
            background: #111; color: #00FF00; border: 2px solid #00FF00;
            padding: 15px 30px; margin: 10px; font-size: 18px; cursor: pointer;
            width: 80%; max-width: 300px; border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,255,0,0.3);
            text-transform: uppercase;
        }
        .menu-btn:active { background: #00FF00; color: black; }

        #score { font-size: 90px; font-weight: bold; margin: 10px 0; }
        #timer { font-size: 24px; color: yellow; font-variant-numeric: tabular-nums; /* 数字の幅を固定してガタつき防止 */ }
        #instruction { font-size: 14px; color: cyan; margin-bottom: 20px; min-height: 24px;}
        
        /* インジケーター（光る玉） */
        .btn-indicators { display: flex; gap: 15px; margin-bottom: 20px; }
        .indicator {
            width: 50px; height: 50px; border: 2px solid #333; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; color: #555;
            font-weight: bold; font-size: 20px; transition: transform 0.05s;
        }
        /* 正解のターゲット */
        .indicator.target { 
            border-color: yellow; color: yellow; 
            box-shadow: 0 0 10px yellow; transform: scale(1.1);
        }
        /* 押した瞬間の光 */
        .indicator.lit { 
            background: #00FF00; color: black; border-color: #00FF00; 
            box-shadow: 0 0 20px #00FF00; transform: scale(1.2);
        }

        .config-row { margin: 8px; border: 1px solid #333; padding: 10px; width: 85%; font-size: 14px;}
        .waiting { color: yellow; animation: blink 0.5s infinite; }
        
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>
<a href="index.html" style="font-size:20px; color:blue;">反応速度アプリに移動</a>
    
    <div id="screen-menu" class="screen active">
        <h1>RAPID EDGE <span style="color:cyan">OMEGA</span></h1>
        <p style="color:#888; font-size:12px">HIGH PERFORMANCE EDITION</p>
        
        <button class="menu-btn" onclick="goToGame('single')">SINGLE (1 Btn)</button>
        <button class="menu-btn" onclick="goToGame('dual')">DUAL (交互押し)</button>
        <button class="menu-btn" onclick="goToGame('order')">ORDER (順番押し)</button>
        <br>
        <button class="menu-btn" style="border-color:#888; color:#888" onclick="goToConfig()">[ KEY CONFIG ]</button>
        <div id="status-bar" style="margin-top:20px; font-size:12px; color:#555">DETECTING CONTROLLER...</div>
    </div>

    <div id="screen-game" class="screen">
        <div id="timer">READY</div>
        <div id="score">0</div>
        <div id="instruction">...</div>
        
        <div class="btn-indicators" id="game-indicators"></div>

        <button class="menu-btn" onclick="backToMenu()" style="margin-top:40px; border-color:red; color:red; font-size:14px">EXIT</button>
    </div>

    <div id="screen-result" class="screen">
        <h1 style="font-size:30px">TIME UP!</h1>
        <div id="final-score" style="font-size:80px; color:white">0</div>
        <div id="rank" style="font-size:24px; color:cyan; margin:10px">RANK: CALC...</div>
        <div style="color:yellow; margin-top:30px; font-size:14px" id="retry-msg">PUSH [RESET] TO RETURN</div>
    </div>

    <div id="screen-config" class="screen">
        <h2>KEY CONFIG</h2>
        <div class="config-row" id="cfg-btn1" onclick="startBinding(0)">BUTTON 1: <span class="val">NOT SET</span></div>
        <div class="config-row" id="cfg-btn2" onclick="startBinding(1)">BUTTON 2: <span class="val">NOT SET</span></div>
        <div class="config-row" id="cfg-btn3" onclick="startBinding(2)">BUTTON 3: <span class="val">NOT SET</span></div>
        <div class="config-row" id="cfg-reset" onclick="startBinding(3)" style="border-color:cyan">RESET KEY: <span class="val">NOT SET</span></div>
        <button class="menu-btn" onclick="backToMenu()">SAVE & BACK</button>
    </div>

    <script>
        // 要素のキャッシュ（高速化のため）
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const statusEl = document.getElementById('status-bar');
        
        // 設定
        let keyMap = [0, 1, 2, 0]; 
        
        let currentMode = 'single';
        let gameState = 'menu';
        let count = 0;
        let isRunning = false;
        
        // タイマー管理（高精度）
        let startTime = 0;
        let timeLimit = 10000; // 10秒 (ミリ秒)
        
        // 判定用
        let orderIndex = 0;
        let lastDualBtnIndex = -1;
        let wasPressed = [false, false, false, false]; 

        // Config用
        let isBinding = false;
        let bindingTarget = -1;

        // ゲームパッドIDキャッシュ
        let lastGamepadId = "";

        // メインループ
        function loop() {
            // ループ内で毎回DOM検索しないように最適化
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            let gp = null;
            for(let g of gamepads) { if(g && g.buttons) { gp = g; break; } }

            // ステータス表示の更新頻度を抑制
            if(gp && gp.id !== lastGamepadId) {
                statusEl.innerText = "CONNECTED: " + gp.id;
                statusEl.style.color = "#00FF00";
                lastGamepadId = gp.id;
            } else if (!gp && lastGamepadId !== "") {
                statusEl.innerText = "CONNECT CONTROLLER...";
                statusEl.style.color = "#555";
                lastGamepadId = "";
            }

            if(gp) {
                if(gameState === 'config' && isBinding) {
                    for(let i=0; i<gp.buttons.length; i++) {
                        if(gp.buttons[i].pressed) { setKeyBinding(i); break; }
                    }
                }
                else if(gameState === 'game') {
                    handleGameInput(gp);
                    
                    // タイマー更新（高精度計算）
                    if(isRunning) {
                        let elapsed = performance.now() - startTime;
                        let remain = Math.max(0, (timeLimit - elapsed) / 1000);
                        timerEl.innerText = remain.toFixed(2);
                        if(remain <= 0) endGame();
                    }
                }
                else if(gameState === 'result') {
                    // リセット
                    if(gp.buttons[keyMap[3]] && gp.buttons[keyMap[3]].pressed) {
                        backToMenu();
                    }
                }
            }
            requestAnimationFrame(loop);
        }
        loop();

        function handleGameInput(gp) {
            // モードに応じたターゲットボタン定義
            let targets = [];
            if(currentMode === 'single') targets = [0];
            else if(currentMode === 'dual') targets = [0, 1];
            else if(currentMode === 'order') targets = [0, 1, 2];

            // 入力判定
            for(let i=0; i<targets.length; i++) {
                let mapIdx = targets[i];
                let actualBtn = keyMap[mapIdx];
                let btnObj = gp.buttons[actualBtn];
                
                if(!btnObj) continue;

                if(btnObj.pressed) {
                    if(!wasPressed[i]) {
                        onPress(i); 
                        wasPressed[i] = true;
                    }
                } else {
                    wasPressed[i] = false;
                }
            }
        }

        function onPress(btnIndex) {
            // スタート処理
            if(!isRunning && gameState === 'game' && timerEl.innerText === "READY") {
                startGame();
            }
            if(!isRunning) return;

            let validHit = false;

            // 判定ロジック
            if(currentMode === 'single') {
                validHit = true; 
            } 
            else if(currentMode === 'dual') {
                if(btnIndex !== lastDualBtnIndex) {
                    validHit = true;
                    lastDualBtnIndex = btnIndex;
                    // 次のターゲット表示更新
                    let nextTarget = (btnIndex === 0) ? 1 : 0;
                    setTargetIndicator(nextTarget);
                }
            }
            else if(currentMode === 'order') {
                if(btnIndex === orderIndex) {
                    validHit = true;
                    orderIndex++;
                    if(orderIndex >= 3) orderIndex = 0;
                    setTargetIndicator(orderIndex); // 次の場所だけ光らせる
                }
            }

            if(validHit) {
                count++;
                scoreEl.innerText = count;
                
                // 光る演出 (DOM負荷軽減のためクラス付替のみ)
                let el = document.getElementById('ind-' + btnIndex);
                if(el) {
                    // アニメーションのリセットテクニック
                    el.classList.remove('lit');
                    void el.offsetWidth; // 強制再描画
                    el.classList.add('lit');
                }
                // ※振動機能(vibrate)はラグの原因になるため削除しました
            }
        }

        // インジケータ制御（必要な時だけ呼ぶように修正）
        function setTargetIndicator(targetIdx) {
            // 一旦全部消す
            let all = document.querySelectorAll('.indicator');
            all.forEach(el => el.classList.remove('target'));
            
            // 指定箇所だけつける
            let el = document.getElementById('ind-' + targetIdx);
            if(el) el.classList.add('target');
        }

        // Dualモード初期化用（両方光らせる）
        function setDualTargets() {
            document.getElementById('ind-0').classList.add('target');
            document.getElementById('ind-1').classList.add('target');
        }

        function startGame() {
            isRunning = true;
            timerEl.style.color = "white";
            document.getElementById('instruction').innerText = "GO !!!";
            startTime = performance.now(); // 正確な時間計測開始
        }

        function endGame() {
            isRunning = false;
            
            document.getElementById('final-score').innerText = count;
            
            // ランク計算
            let rank = "B";
            if(count >= 80) rank = "SSS (GOD)";
            else if(count >= 70) rank = "SS (MASTER)";
            else if(count >= 55) rank = "S (PRO)";
            else if(count >= 40) rank = "A (GOOD)";
            
            document.getElementById('rank').innerText = "RANK: " + rank;
            document.getElementById('retry-msg').innerText = "PUSH [RESET KEY] TO RETURN";
            
            switchScreen('screen-result');
            gameState = 'result';
        }

        function switchScreen(id) {
            document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function goToGame(mode) {
            currentMode = mode;
            gameState = 'game';
            count = 0;
            orderIndex = 0;
            lastDualBtnIndex = -1;
            
            scoreEl.innerText = "0";
            timerEl.innerText = "READY";
            timerEl.style.color = "yellow";
            isRunning = false;

            let parent = document.getElementById('game-indicators');
            parent.innerHTML = "";
            let num = (mode==='single')?1 : (mode==='dual')?2 : 3;
            
            let msg = "";
            if(mode==='single') msg = "1つのボタンを連打せよ";
            if(mode==='dual')   msg = "2つのボタンを交互に連打せよ";
            if(mode==='order')  msg = "光るボタンを順番に押せ";
            document.getElementById('instruction').innerText = msg;

            for(let i=0; i<num; i++) {
                let div = document.createElement('div');
                div.className = 'indicator';
                div.id = 'ind-' + i;
                div.innerText = i+1;
                parent.appendChild(div);
            }
            
            // 初期ターゲット設定
            if(mode === 'order') setTargetIndicator(0);
            if(mode === 'dual')  setDualTargets();
            if(mode === 'single') setTargetIndicator(0); // シングルも光らせておく

            switchScreen('screen-game');
        }

        function backToMenu() {
            gameState = 'menu';
            switchScreen('screen-menu');
        }

        function goToConfig() {
            gameState = 'config';
            switchScreen('screen-config');
            updateConfigUI();
        }

        function startBinding(targetIdx) {
            isBinding = true;
            bindingTarget = targetIdx;
            let ids = ['cfg-btn1', 'cfg-btn2', 'cfg-btn3', 'cfg-reset'];
            document.getElementById(ids[targetIdx]).querySelector('.val').innerHTML = "<span class='waiting'>PUSH BUTTON...</span>";
        }

        function setKeyBinding(btnCode) {
            isBinding = false;
            keyMap[bindingTarget] = btnCode;
            updateConfigUI();
            setTimeout(() => { bindingTarget = -1; }, 200);
        }

        function updateConfigUI() {
            let ids = ['cfg-btn1', 'cfg-btn2', 'cfg-btn3', 'cfg-reset'];
            for(let i=0; i<4; i++) {
                let el = document.getElementById(ids[i]).querySelector('.val');
                el.innerText = "BTN ID: " + keyMap[i];
                el.style.color = "#00FF00";
            }
        }
    </script>
</body>
</html>
